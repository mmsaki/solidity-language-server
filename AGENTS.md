## Agents

- User `jq` to analyze json outputs from ast.
- [poolmanager.json](./poolmanager.json) - ast generated by solc.

## Testing and Debugging

Always use `lsp-bench` as the first choice when you want to debug lsp methods and their output. The lsp-bench is located locally at ../solidity-lsp-benchmarks.

There are many examples on ./benchmarks on how to write a simple yaml config to you needs.

## Building

Always build with `--release` flag

## Memory Optimization Notes (branch: 129-solc-ast-module)

### Current state (as of ba14676)

| State | RSS | vs v0.1.24 |
|---|---|---|
| v0.1.24 baseline | 228 MB | — |
| Before this work (pre-branch) | 394 MB | +166 MB |
| After extract_decl_nodes + remove ast field | 309 MB | +81 MB |

Reclaimed ~85 MB of the 166 MB regression. The remaining +81 MB gap needs DHAT
profiling to identify where the bytes are going. Suspected sources:

- **P1: ContractDefinition.nodes full clone** (~10-20 MB) — retained for
  `resolve_inheritdoc_typed()`. Only needs selectors + doc text, not the full
  child nodes. Could build a lightweight struct instead.
- **P2: extract_decl_nodes clone-then-strip** (~5-10 MB peak) — clones each
  node Value before stripping heavy fields. Could build a filtered Map directly
  instead of clone-then-mutate.
- **P3: CompletionCache.general_completions** (~2-5 MB) — duplicates `names`
  from the node index.
- **New data structures** — `decl_index` and `node_id_to_source_path` are new
  indexes that didn't exist in v0.1.24, contributing some baseline overhead.

### DHAT profiling results (poolmanager-t-full.json, 95 files)

```
Total allocated: 634 MB (transient + retained)
Peak (t-gmax):   277 MB
Retained (t-end):  60 MB  (what CachedBuild actually holds)
RSS observed:     309 MB  (60 MB data + allocator fragmentation from 634 MB churn)
```

**Retained memory breakdown (t-end):**

| # | Retained | Source | Notes |
|---|---|---|---|
| 1 | 16.4 MB | `cache_ids()` → `nodes` HashMap | All AST nodes with src, referencedDeclaration, etc. Existed in v0.1.24 too. |
| 2 | 12.6 MB | `walk_and_extract()` → `decl_index` + `node_id_to_source_path` | **New** — typed declaration index. |
| 3 | 4.1 MB | `FunctionDefinition` structs in `decl_index` | **New** |
| 4 | 4.1 MB | `ContractDefinition` structs (includes child `nodes` array) | **New** — P1 target. |
| 5 | 2.0 MB | `VariableDeclaration` structs | **New** |
| 6 | 1.9 MB | `CompletionCache` | Partially new. |
| 7+ | 3.4 MB | Strings, other indexes | Mixed. |

**Key insight:** The ~81 MB RSS gap vs v0.1.24 is NOT 81 MB of retained data. It's
~23 MB of new data structures (`decl_index` + `DeclNode` contents) plus ~58 MB of
allocator fragmentation from the 634 MB of transient allocations during `CachedBuild::new()`.

### Next steps

1. **Reduce transient churn** — the 634 MB of total allocations causes fragmentation
   that inflates RSS. The biggest source is `cache_ids()` which builds `nodes` from
   scratch on every build. Consider:
   - Pre-sizing HashMaps with `with_capacity()` based on source count
   - Reducing `node_value.clone()` in `extract_decl_nodes` (P2)
2. **P1: ContractDefinition.nodes** (4.1 MB) — only needs selectors + doc text for
   `resolve_inheritdoc_typed()`, not the full child nodes
3. **P3: CompletionCache** (1.9 MB) — check for name duplication with `nodes`
4. Re-measure after each change
